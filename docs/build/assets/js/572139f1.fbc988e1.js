"use strict";(globalThis.webpackChunkkafka_backup_docs=globalThis.webpackChunkkafka_backup_docs||[]).push([[6535],{5821:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"troubleshooting/offset-discontinuity","title":"Offset Discontinuity","description":"Troubleshooting offset-related issues after restore","source":"@site/docs/troubleshooting/offset-discontinuity.md","sourceDirName":"troubleshooting","slug":"/troubleshooting/offset-discontinuity","permalink":"/troubleshooting/offset-discontinuity","draft":false,"unlisted":false,"editUrl":"https://github.com/osodevops/kafka-backup-docs/tree/main/docs/docs/troubleshooting/offset-discontinuity.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Offset Discontinuity","description":"Troubleshooting offset-related issues after restore","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Performance Issues","permalink":"/troubleshooting/performance-issues"},"next":{"title":"Debug Mode","permalink":"/troubleshooting/debug-mode"}}');var t=n(4848),o=n(8453);const a={title:"Offset Discontinuity",description:"Troubleshooting offset-related issues after restore",sidebar_position:3},i="Offset Discontinuity",c={},l=[{value:"Understanding the Problem",id:"understanding-the-problem",level:2},{value:"What is Offset Discontinuity?",id:"what-is-offset-discontinuity",level:3},{value:"Why Do Offsets Change?",id:"why-do-offsets-change",level:3},{value:"Diagnosing Offset Issues",id:"diagnosing-offset-issues",level:2},{value:"Check Consumer Position",id:"check-consumer-position",level:3},{value:"Check Restored Data",id:"check-restored-data",level:3},{value:"Find Offset Mapping",id:"find-offset-mapping",level:3},{value:"Solutions",id:"solutions",level:2},{value:"Solution 1: Header-Based Offset Reset",id:"solution-1-header-based-offset-reset",level:3},{value:"Solution 2: Timestamp-Based Reset",id:"solution-2-timestamp-based-reset",level:3},{value:"Solution 3: Start from Beginning",id:"solution-3-start-from-beginning",level:3},{value:"Solution 4: Use Offset Mapping File",id:"solution-4-use-offset-mapping-file",level:3},{value:"Three-Phase Restore (Recommended)",id:"three-phase-restore-recommended",level:2},{value:"Handling Specific Scenarios",id:"handling-specific-scenarios",level:2},{value:"Scenario: PITR Restore",id:"scenario-pitr-restore",level:3},{value:"Scenario: Partition Count Change",id:"scenario-partition-count-change",level:3},{value:"Scenario: Topic Remapping",id:"scenario-topic-remapping",level:3},{value:"Scenario: Compacted Topics",id:"scenario-compacted-topics",level:3},{value:"Offset Rollback",id:"offset-rollback",level:2},{value:"Create Snapshot Before Reset",id:"create-snapshot-before-reset",level:3},{value:"Using the Operator",id:"using-the-operator",level:3},{value:"Verifying Offset Correctness",id:"verifying-offset-correctness",level:2},{value:"Check Message at Position",id:"check-message-at-position",level:3},{value:"Compare Source and Target",id:"compare-source-and-target",level:3},{value:"Verify Consumer Group",id:"verify-consumer-group",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting Checklist",id:"troubleshooting-checklist",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"offset-discontinuity",children:"Offset Discontinuity"})}),"\n",(0,t.jsx)(s.p,{children:"After restoring Kafka data, consumers may encounter offset discontinuities. This guide explains the causes and solutions."}),"\n",(0,t.jsx)(s.h2,{id:"understanding-the-problem",children:"Understanding the Problem"}),"\n",(0,t.jsx)(s.h3,{id:"what-is-offset-discontinuity",children:"What is Offset Discontinuity?"}),"\n",(0,t.jsx)(s.p,{children:"Kafka offsets are sequential numbers assigned to each message. After restore:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"Source Cluster Offsets:        Target Cluster Offsets:\n0, 1, 2, 3, 4, 5, ...         0, 1, 2, 3, 4, 5, ...\n         \u2502                             \u2502\n         \u25bc                             \u25bc\n   Consumer at offset 1000       Consumer at offset ???\n"})}),"\n",(0,t.jsx)(s.p,{children:"The problem: Consumer offset 1000 from source may not correspond to the same message in target."}),"\n",(0,t.jsx)(s.h3,{id:"why-do-offsets-change",children:"Why Do Offsets Change?"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Fresh topic starts at 0"})," - New topic always begins at offset 0"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"PITR filtering"})," - Not all messages restored"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Compacted topics"})," - Different compaction state"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Different partition count"})," - Records redistributed"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"diagnosing-offset-issues",children:"Diagnosing Offset Issues"}),"\n",(0,t.jsx)(s.h3,{id:"check-consumer-position",children:"Check Consumer Position"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Source cluster (before migration)\nkafka-consumer-groups \\\n  --bootstrap-server source-kafka:9092 \\\n  --group order-processor \\\n  --describe\n\n# Output:\n# TOPIC     PARTITION  CURRENT-OFFSET  LOG-END-OFFSET\n# orders    0          1000            1500\n# orders    1          800             1200\n"})}),"\n",(0,t.jsx)(s.h3,{id:"check-restored-data",children:"Check Restored Data"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Target cluster (after restore)\nkafka-run-class kafka.tools.GetOffsetShell \\\n  --broker-list target-kafka:9092 \\\n  --topic orders\n\n# Output:\n# orders:0:0:500     (partition 0 has 500 messages, starting at 0)\n# orders:1:0:400     (partition 1 has 400 messages, starting at 0)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"find-offset-mapping",children:"Find Offset Mapping"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:'# Use OSO Kafka Backup to find mapping\nkafka-backup show-offset-mapping \\\n  --bootstrap-servers target-kafka:9092 \\\n  --topic orders \\\n  --source-cluster "source-cluster-id"\n\n# Output:\n# Partition 0: Source offset 500-1000 \u2192 Target offset 0-500\n# Partition 1: Source offset 400-800 \u2192 Target offset 0-400\n'})}),"\n",(0,t.jsx)(s.h2,{id:"solutions",children:"Solutions"}),"\n",(0,t.jsx)(s.h3,{id:"solution-1-header-based-offset-reset",children:"Solution 1: Header-Based Offset Reset"}),"\n",(0,t.jsx)(s.p,{children:"OSO Kafka Backup stores original offsets in headers. Use this to find correct position:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:'# Generate offset reset plan\nkafka-backup offset-reset plan \\\n  --bootstrap-servers target-kafka:9092 \\\n  --groups order-processor \\\n  --strategy header-based \\\n  --source-cluster "source-cluster-id" \\\n  --output reset-plan.json\n\n# Review plan\ncat reset-plan.json\n\n# Execute\nkafka-backup offset-reset execute \\\n  --plan reset-plan.json \\\n  --bootstrap-servers target-kafka:9092\n'})}),"\n",(0,t.jsx)(s.p,{children:"Configuration:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:'offset_reset:\n  strategy: header-based\n  source_cluster: "source-cluster-id"\n  groups:\n    - order-processor\n    - payment-processor\n'})}),"\n",(0,t.jsx)(s.h3,{id:"solution-2-timestamp-based-reset",children:"Solution 2: Timestamp-Based Reset"}),"\n",(0,t.jsx)(s.p,{children:"If headers aren't available, use timestamps:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Reset to timestamp\nkafka-consumer-groups \\\n  --bootstrap-server target-kafka:9092 \\\n  --group order-processor \\\n  --reset-offsets \\\n  --to-datetime 2024-12-01T10:00:00.000 \\\n  --all-topics \\\n  --execute\n"})}),"\n",(0,t.jsx)(s.p,{children:"Or using OSO Kafka Backup:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"offset_reset:\n  strategy: timestamp\n  timestamp: 1701421200000  # Unix timestamp in milliseconds\n  groups:\n    - order-processor\n"})}),"\n",(0,t.jsx)(s.h3,{id:"solution-3-start-from-beginning",children:"Solution 3: Start from Beginning"}),"\n",(0,t.jsx)(s.p,{children:"If reprocessing is acceptable:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"kafka-consumer-groups \\\n  --bootstrap-server target-kafka:9092 \\\n  --group order-processor \\\n  --reset-offsets \\\n  --to-earliest \\\n  --all-topics \\\n  --execute\n"})}),"\n",(0,t.jsx)(s.h3,{id:"solution-4-use-offset-mapping-file",children:"Solution 4: Use Offset Mapping File"}),"\n",(0,t.jsx)(s.p,{children:"For precise control:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Generate mapping during restore\nkafka-backup restore \\\n  --config restore.yaml \\\n  --generate-offset-mapping \\\n  --mapping-output offset-mapping.json\n\n# Apply mapping\nkafka-backup offset-reset execute \\\n  --strategy from-mapping \\\n  --mapping-file offset-mapping.json \\\n  --groups order-processor\n"})}),"\n",(0,t.jsx)(s.h2,{id:"three-phase-restore-recommended",children:"Three-Phase Restore (Recommended)"}),"\n",(0,t.jsx)(s.p,{children:"The three-phase restore handles offset translation automatically:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"kafka-backup three-phase-restore --config restore.yaml\n"})}),"\n",(0,t.jsx)(s.p,{children:"What it does:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"Phase 1: Restore Data\n\u251c\u2500\u2500 Restore messages to target\n\u2514\u2500\u2500 Include offset headers\n\nPhase 2: Build Mapping\n\u251c\u2500\u2500 Scan restored messages\n\u2514\u2500\u2500 Build source\u2192target offset map\n\nPhase 3: Reset Offsets\n\u251c\u2500\u2500 Read consumer group positions\n\u251c\u2500\u2500 Translate to target offsets\n\u2514\u2500\u2500 Reset consumer groups\n"})}),"\n",(0,t.jsx)(s.p,{children:"Configuration:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:'mode: restore\nbackup_id: "my-backup"\n\ntarget:\n  bootstrap_servers:\n    - target-kafka:9092\n\nrestore:\n  include_original_offset_header: true\n  consumer_group_strategy: header-based\n  reset_consumer_offsets: true\n  consumer_groups:\n    - order-processor\n    - payment-processor\n    - notification-service\n\nstorage:\n  backend: s3\n  bucket: kafka-backups\n  prefix: production\n'})}),"\n",(0,t.jsx)(s.h2,{id:"handling-specific-scenarios",children:"Handling Specific Scenarios"}),"\n",(0,t.jsx)(s.h3,{id:"scenario-pitr-restore",children:"Scenario: PITR Restore"}),"\n",(0,t.jsx)(s.p,{children:"When using point-in-time recovery, some messages are excluded:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"Source: Messages at T=1,2,3,4,5,6,7,8,9,10\nPITR: Only restore T=3-7\nTarget: Messages at T=3,4,5,6,7 (offsets 0-4)\n\nConsumer was at: T=5 (source offset 5)\nShould be at: T=5 (target offset 2)\n"})}),"\n",(0,t.jsx)(s.p,{children:"Solution:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"restore:\n  time_window_start: 1701388800000  # T=3\n  time_window_end: 1701410400000    # T=7\n  include_original_offset_header: true\n\noffset_reset:\n  strategy: header-based\n  # Will find T=5 in target and map correctly\n"})}),"\n",(0,t.jsx)(s.h3,{id:"scenario-partition-count-change",children:"Scenario: Partition Count Change"}),"\n",(0,t.jsx)(s.p,{children:"When partition count differs:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'Source: 6 partitions\nTarget: 12 partitions\n\nMessage with key "order-123":\n  Source: Partition 2, Offset 500\n  Target: Partition 8, Offset 50 (different partition!)\n'})}),"\n",(0,t.jsx)(s.p,{children:"Solution:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"offset_reset:\n  strategy: header-based\n  scan_all_partitions: true  # Required for partition changes\n"})}),"\n",(0,t.jsx)(s.h3,{id:"scenario-topic-remapping",children:"Scenario: Topic Remapping"}),"\n",(0,t.jsx)(s.p,{children:"When topics are renamed:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"restore:\n  topic_mapping:\n    orders: restored-orders\n    payments: restored-payments\n\noffset_reset:\n  strategy: header-based\n  topic_mapping:\n    orders: restored-orders\n    payments: restored-payments\n"})}),"\n",(0,t.jsx)(s.h3,{id:"scenario-compacted-topics",children:"Scenario: Compacted Topics"}),"\n",(0,t.jsx)(s.p,{children:"Compacted topics may have different records:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"Source: Keys A(v1), B(v1), A(v2), C(v1), B(v2)\n        Compacted: A(v2), C(v1), B(v2)\n\nBackup: A(v2), C(v1), B(v2) (3 records)\n\nTarget after restore: A(v2), C(v1), B(v2) at offsets 0,1,2\n"})}),"\n",(0,t.jsx)(s.p,{children:"For compacted topics, timestamp or header-based reset works best."}),"\n",(0,t.jsx)(s.h2,{id:"offset-rollback",children:"Offset Rollback"}),"\n",(0,t.jsx)(s.p,{children:"If offset reset causes problems, rollback to previous position:"}),"\n",(0,t.jsx)(s.h3,{id:"create-snapshot-before-reset",children:"Create Snapshot Before Reset"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Snapshot current offsets\nkafka-backup offset-rollback snapshot \\\n  --bootstrap-servers target-kafka:9092 \\\n  --groups order-processor \\\n  --output pre-reset-snapshot.json\n\n# Perform reset\nkafka-backup offset-reset execute ...\n\n# If problems, rollback\nkafka-backup offset-rollback rollback \\\n  --bootstrap-servers target-kafka:9092 \\\n  --snapshot pre-reset-snapshot.json\n"})}),"\n",(0,t.jsx)(s.h3,{id:"using-the-operator",children:"Using the Operator"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"apiVersion: kafka.oso.sh/v1alpha1\nkind: KafkaOffsetRollback\nmetadata:\n  name: rollback-order-processor\nspec:\n  kafkaCluster:\n    bootstrapServers:\n      - kafka:9092\n  consumerGroups:\n    - order-processor\n  operation: snapshot\n  snapshotId: pre-reset\n"})}),"\n",(0,t.jsx)(s.h2,{id:"verifying-offset-correctness",children:"Verifying Offset Correctness"}),"\n",(0,t.jsx)(s.h3,{id:"check-message-at-position",children:"Check Message at Position"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Get message at specific offset\nkafka-console-consumer \\\n  --bootstrap-server target-kafka:9092 \\\n  --topic orders \\\n  --partition 0 \\\n  --offset 100 \\\n  --max-messages 1 \\\n  --property print.headers=true\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Look for ",(0,t.jsx)(s.code,{children:"x-kafka-backup-offset"})," header to verify original offset."]}),"\n",(0,t.jsx)(s.h3,{id:"compare-source-and-target",children:"Compare Source and Target"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Source message at offset 1000\nkafka-console-consumer \\\n  --bootstrap-server source-kafka:9092 \\\n  --topic orders \\\n  --partition 0 \\\n  --offset 1000 \\\n  --max-messages 1 \\\n  --property print.key=true\n\n# Target message (should be same content)\nkafka-console-consumer \\\n  --bootstrap-server target-kafka:9092 \\\n  --topic orders \\\n  --partition 0 \\\n  --offset 500 \\\n  --max-messages 1 \\\n  --property print.key=true\n"})}),"\n",(0,t.jsx)(s.h3,{id:"verify-consumer-group",children:"Verify Consumer Group"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Check consumer group can consume\nkafka-consumer-groups \\\n  --bootstrap-server target-kafka:9092 \\\n  --group order-processor \\\n  --describe\n\n# LAG should be reasonable after reset\n"})}),"\n",(0,t.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Always include offset headers"})," during backup"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use three-phase restore"})," for complete migrations"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Take offset snapshots"})," before any reset"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Test with single consumer group"})," before bulk reset"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Verify data correctness"})," after reset"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Monitor consumer lag"})," after restart"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"troubleshooting-checklist",children:"Troubleshooting Checklist"}),"\n",(0,t.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Was backup created with ",(0,t.jsx)(s.code,{children:"include_offset_headers: true"}),"?"]}),"\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Is ",(0,t.jsx)(s.code,{children:"source_cluster_id"})," correctly specified?"]}),"\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Are consumer groups stopped before reset?"]}),"\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Is the correct strategy being used?"]}),"\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","For partition changes, is ",(0,t.jsx)(s.code,{children:"scan_all_partitions"})," enabled?"]}),"\n",(0,t.jsxs)(s.li,{className:"task-list-item",children:[(0,t.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Are topic mappings consistent between restore and offset reset?"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"../guides/offset-management",children:"Offset Management Guide"})," - Detailed offset operations"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"../architecture/offset-translation",children:"Offset Translation Architecture"})," - How it works"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"../reference/cli-reference#offset-reset",children:"CLI Reference"})," - Command options"]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>i});var r=n(6540);const t={},o=r.createContext(t);function a(e){const s=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);