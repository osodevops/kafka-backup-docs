"use strict";(globalThis.webpackChunkkafka_backup_docs=globalThis.webpackChunkkafka_backup_docs||[]).push([[7820],{8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var r=s(6540);const t={},a=r.createContext(t);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},9890:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"architecture/offset-translation","title":"Offset Translation","description":"Understanding how OSO Kafka Backup handles offset mapping between clusters","source":"@site/docs/architecture/offset-translation.md","sourceDirName":"architecture","slug":"/architecture/offset-translation","permalink":"/architecture/offset-translation","draft":false,"unlisted":false,"editUrl":"https://github.com/osodevops/kafka-backup-docs/tree/main/docs/docs/architecture/offset-translation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Offset Translation","description":"Understanding how OSO Kafka Backup handles offset mapping between clusters","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Architecture Overview","permalink":"/architecture/overview"},"next":{"title":"PITR Implementation","permalink":"/architecture/pitr-implementation"}}');var t=s(4848),a=s(8453);const i={title:"Offset Translation",description:"Understanding how OSO Kafka Backup handles offset mapping between clusters",sidebar_position:2},o="Offset Translation",c={},d=[{value:"The Offset Problem",id:"the-offset-problem",level:2},{value:"Why Offsets Don&#39;t Transfer Directly",id:"why-offsets-dont-transfer-directly",level:3},{value:"The Solution: Header-Based Translation",id:"the-solution-header-based-translation",level:3},{value:"Header Format",id:"header-format",level:2},{value:"Standard Headers",id:"standard-headers",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Offset Mapping Process",id:"offset-mapping-process",level:2},{value:"Building the Mapping",id:"building-the-mapping",level:3},{value:"Generate Mapping",id:"generate-mapping",level:3},{value:"Consumer Offset Reset",id:"consumer-offset-reset",level:2},{value:"Reset Strategies",id:"reset-strategies",level:3},{value:"1. Header-Based (Recommended)",id:"1-header-based-recommended",level:4},{value:"2. Timestamp-Based",id:"2-timestamp-based",level:4},{value:"3. Earliest/Latest",id:"3-earliestlatest",level:4},{value:"4. Specific Offset",id:"4-specific-offset",level:4},{value:"5. From Mapping File",id:"5-from-mapping-file",level:4},{value:"Executing Offset Reset",id:"executing-offset-reset",level:3},{value:"Three-Phase Restore",id:"three-phase-restore",level:2},{value:"Handling Edge Cases",id:"handling-edge-cases",level:2},{value:"Offset Gaps",id:"offset-gaps",level:3},{value:"Compacted Topics",id:"compacted-topics",level:3},{value:"Partition Count Changes",id:"partition-count-changes",level:3},{value:"Topic Remapping",id:"topic-remapping",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Header Scanning Performance",id:"header-scanning-performance",level:3},{value:"Bulk Offset Reset",id:"bulk-offset-reset",level:3},{value:"Caching",id:"caching",level:3},{value:"Verification",id:"verification",level:2},{value:"Verify Offset Reset",id:"verify-offset-reset",level:3},{value:"Verify Data Continuity",id:"verify-data-continuity",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"offset-translation",children:"Offset Translation"})}),"\n",(0,t.jsx)(n.p,{children:"One of the most challenging aspects of Kafka backup and restore is maintaining consumer position across clusters. OSO Kafka Backup solves this through offset translation."}),"\n",(0,t.jsx)(n.h2,{id:"the-offset-problem",children:"The Offset Problem"}),"\n",(0,t.jsx)(n.h3,{id:"why-offsets-dont-transfer-directly",children:"Why Offsets Don't Transfer Directly"}),"\n",(0,t.jsx)(n.p,{children:"Kafka offsets are cluster-specific and cannot be directly transferred:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Source Cluster                    Target Cluster\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Topic: orders          \u2502       \u2502 Topic: orders          \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502       \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 Offset 0: Order A  \u2502 \u2502  \u2500\u2500\u2500\u25b6 \u2502 \u2502 Offset 0: Order A  \u2502 \u2502\n\u2502 \u2502 Offset 1: Order B  \u2502 \u2502       \u2502 \u2502 Offset 1: Order B  \u2502 \u2502\n\u2502 \u2502 Offset 2: Order C  \u2502 \u2502       \u2502 \u2502 Offset 2: Order C  \u2502 \u2502\n\u2502 \u2502 ...                \u2502 \u2502       \u2502 \u2502 ...                \u2502 \u2502\n\u2502 \u2502 Offset 999: Last   \u2502 \u2502       \u2502 \u2502 Offset 999: Last   \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u274c Offsets may differ!\n"})}),"\n",(0,t.jsx)(n.p,{children:"Offsets can differ because:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compacted topics"})," - Different compaction states"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partial restore"})," - PITR excludes some messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topic recreation"})," - Fresh topic starts at 0"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partition changes"})," - Different partition count"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"the-solution-header-based-translation",children:"The Solution: Header-Based Translation"}),"\n",(0,t.jsx)(n.p,{children:"OSO Kafka Backup stores original offset information in message headers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Original Message (Source)          Restored Message (Target)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Offset: 12345           \u2502       \u2502 Offset: 100             \u2502\n\u2502 Key: order-123          \u2502  \u2500\u2500\u2500\u25b6 \u2502 Key: order-123          \u2502\n\u2502 Value: {...}            \u2502       \u2502 Value: {...}            \u2502\n\u2502 Headers: []             \u2502       \u2502 Headers:                \u2502\n\u2502                         \u2502       \u2502   x-kafka-backup-offset \u2502\n\u2502                         \u2502       \u2502     : 12345             \u2502\n\u2502                         \u2502       \u2502   x-kafka-backup-partition\n\u2502                         \u2502       \u2502     : 0                 \u2502\n\u2502                         \u2502       \u2502   x-kafka-backup-cluster\u2502\n\u2502                         \u2502       \u2502     : source-cluster    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h2,{id:"header-format",children:"Header Format"}),"\n",(0,t.jsx)(n.h3,{id:"standard-headers",children:"Standard Headers"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Header"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Example"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"x-kafka-backup-offset"})}),(0,t.jsx)(n.td,{children:"Original offset in source partition"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"12345"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"x-kafka-backup-partition"})}),(0,t.jsx)(n.td,{children:"Original partition number"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"0"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"x-kafka-backup-cluster"})}),(0,t.jsx)(n.td,{children:"Source cluster identifier"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"prod-us-east-1"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"x-kafka-backup-timestamp"})}),(0,t.jsx)(n.td,{children:"Original record timestamp"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"1701234567890"})})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Enable offset headers during backup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'backup:\n  include_offset_headers: true\n  source_cluster_id: "prod-us-east-1"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Preserve during restore:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"restore:\n  include_original_offset_header: true\n"})}),"\n",(0,t.jsx)(n.h2,{id:"offset-mapping-process",children:"Offset Mapping Process"}),"\n",(0,t.jsx)(n.h3,{id:"building-the-mapping",children:"Building the Mapping"}),"\n",(0,t.jsx)(n.p,{children:"After restore, scan headers to build offset mapping:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Offset Mapping Table                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Topic          \u2502 Partition      \u2502 Source Offset  \u2502 Target   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 orders         \u2502 0              \u2502 12345          \u2502 100      \u2502\n\u2502 orders         \u2502 0              \u2502 12346          \u2502 101      \u2502\n\u2502 orders         \u2502 0              \u2502 12347          \u2502 102      \u2502\n\u2502 orders         \u2502 1              \u2502 5000           \u2502 50       \u2502\n\u2502 orders         \u2502 1              \u2502 5001           \u2502 51       \u2502\n\u2502 payments       \u2502 0              \u2502 8000           \u2502 200      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h3,{id:"generate-mapping",children:"Generate Mapping"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'kafka-backup show-offset-mapping \\\n  --bootstrap-servers target-kafka:9092 \\\n  --topic orders \\\n  --source-cluster "prod-us-east-1"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "topic": "orders",\n  "source_cluster": "prod-us-east-1",\n  "mappings": [\n    {\n      "partition": 0,\n      "source_range": {"start": 12345, "end": 15000},\n      "target_range": {"start": 100, "end": 2755}\n    },\n    {\n      "partition": 1,\n      "source_range": {"start": 5000, "end": 7500},\n      "target_range": {"start": 50, "end": 2550}\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"consumer-offset-reset",children:"Consumer Offset Reset"}),"\n",(0,t.jsx)(n.h3,{id:"reset-strategies",children:"Reset Strategies"}),"\n",(0,t.jsx)(n.p,{children:"OSO Kafka Backup supports multiple strategies for resetting consumer offsets:"}),"\n",(0,t.jsx)(n.h4,{id:"1-header-based-recommended",children:"1. Header-Based (Recommended)"}),"\n",(0,t.jsx)(n.p,{children:"Find target offset by scanning for original offset in headers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'offset_reset:\n  strategy: header-based\n  source_cluster: "prod-us-east-1"\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Consumer Group: order-processor\nSource Offset: 12345 (topic: orders, partition: 0)\n\nScan target topic for x-kafka-backup-offset: 12345\n  \u2193\nFound at target offset: 100\n  \u2193\nReset consumer to offset: 100\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-timestamp-based",children:"2. Timestamp-Based"}),"\n",(0,t.jsx)(n.p,{children:"Find target offset by matching record timestamp:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"offset_reset:\n  strategy: timestamp\n  timestamp: 1701234567890\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Consumer Group: order-processor\nSource Timestamp: 1701234567890\n\nFind first offset >= timestamp\n  \u2193\nTarget offset: 100\n  \u2193\nReset consumer to offset: 100\n"})}),"\n",(0,t.jsx)(n.h4,{id:"3-earliestlatest",children:"3. Earliest/Latest"}),"\n",(0,t.jsx)(n.p,{children:"Simple reset to beginning or end:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"offset_reset:\n  strategy: earliest  # or: latest\n"})}),"\n",(0,t.jsx)(n.h4,{id:"4-specific-offset",children:"4. Specific Offset"}),"\n",(0,t.jsx)(n.p,{children:"Reset to known offset:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"offset_reset:\n  strategy: offset\n  offset: 100\n"})}),"\n",(0,t.jsx)(n.h4,{id:"5-from-mapping-file",children:"5. From Mapping File"}),"\n",(0,t.jsx)(n.p,{children:"Use pre-generated mapping:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"offset_reset:\n  strategy: from-mapping\n  mapping_file: /path/to/offset-mapping.json\n"})}),"\n",(0,t.jsx)(n.h3,{id:"executing-offset-reset",children:"Executing Offset Reset"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Generate plan\nkafka-backup offset-reset plan \\\n  --config offset-reset.yaml \\\n  --output reset-plan.json\n\n# Review plan\ncat reset-plan.json\n\n# Execute\nkafka-backup offset-reset execute \\\n  --plan reset-plan.json \\\n  --bootstrap-servers target-kafka:9092\n"})}),"\n",(0,t.jsx)(n.h2,{id:"three-phase-restore",children:"Three-Phase Restore"}),"\n",(0,t.jsx)(n.p,{children:"For complete restoration including consumer offsets:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Phase 1: Data Restore\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Restore messages to target cluster      \u2502\n\u2502 Include offset headers                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nPhase 2: Build Mapping\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan restored topics                    \u2502\n\u2502 Build source\u2192target offset mapping      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nPhase 3: Reset Offsets\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 For each consumer group:                \u2502\n\u2502   Look up source offset                 \u2502\n\u2502   Find corresponding target offset      \u2502\n\u2502   Reset consumer group                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"Execute with single command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kafka-backup three-phase-restore --config restore.yaml\n"})}),"\n",(0,t.jsx)(n.h2,{id:"handling-edge-cases",children:"Handling Edge Cases"}),"\n",(0,t.jsx)(n.h3,{id:"offset-gaps",children:"Offset Gaps"}),"\n",(0,t.jsx)(n.p,{children:"When source offsets have gaps (compaction, deletion):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Source: 100, 101, 105, 106, 110  (gaps at 102-104, 107-109)\nTarget: 0, 1, 2, 3, 4            (contiguous)\n\nMapping:\n  Source 100 \u2192 Target 0\n  Source 101 \u2192 Target 1\n  Source 105 \u2192 Target 2  (gap handled)\n  Source 106 \u2192 Target 3\n  Source 110 \u2192 Target 4\n"})}),"\n",(0,t.jsx)(n.p,{children:"The mapping correctly handles gaps by using the actual records present."}),"\n",(0,t.jsx)(n.h3,{id:"compacted-topics",children:"Compacted Topics"}),"\n",(0,t.jsx)(n.p,{children:"For compacted topics where messages are removed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"backup:\n  include_offset_headers: true\n  # Headers survive compaction if key remains\n"})}),"\n",(0,t.jsx)(n.p,{children:"Consumer reset uses the most recent offset for each key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"If consumer was at offset 100 (key: A)\nBut key A was compacted to offset 200 in source\nThen find the record with key A in target\nReset to that offset\n"})}),"\n",(0,t.jsx)(n.h3,{id:"partition-count-changes",children:"Partition Count Changes"}),"\n",(0,t.jsx)(n.p,{children:"When target has different partition count:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Source: 3 partitions\nTarget: 6 partitions\n\nOriginal message in partition 1, offset 500\nMay land in different partition due to repartitioning\n\nSolution: Include partition in header\nScan ALL partitions in target for matching header\n"})}),"\n",(0,t.jsx)(n.p,{children:"Configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"restore:\n  # Records may be in different partitions\n  include_original_offset_header: true\n\noffset_reset:\n  strategy: header-based\n  scan_all_partitions: true  # Required for partition changes\n"})}),"\n",(0,t.jsx)(n.h3,{id:"topic-remapping",children:"Topic Remapping"}),"\n",(0,t.jsx)(n.p,{children:"When topics are renamed during restore:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"restore:\n  topic_mapping:\n    orders: production-orders\n    payments: production-payments\n"})}),"\n",(0,t.jsx)(n.p,{children:"The offset mapping tracks both:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "source_topic": "orders",\n  "target_topic": "production-orders",\n  "source_cluster": "prod-us-east-1",\n  "mappings": [...]\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"header-scanning-performance",children:"Header Scanning Performance"}),"\n",(0,t.jsx)(n.p,{children:"Scanning headers for offset mapping can be slow for large topics:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"offset_reset:\n  strategy: header-based\n\n  # Performance tuning\n  parallel_consumers: 10      # Parallel partition scanning\n  sample_rate: 1.0           # 1.0 = scan all, 0.1 = 10% sample\n  timeout_secs: 3600         # Max scan time\n"})}),"\n",(0,t.jsx)(n.h3,{id:"bulk-offset-reset",children:"Bulk Offset Reset"}),"\n",(0,t.jsx)(n.p,{children:"For many consumer groups, use bulk reset:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kafka-backup offset-reset-bulk \\\n  --config offset-reset.yaml \\\n  --groups-file consumer-groups.txt \\\n  --parallelism 50\n"})}),"\n",(0,t.jsx)(n.p,{children:"This provides up to 50x speedup for large numbers of consumer groups."}),"\n",(0,t.jsx)(n.h3,{id:"caching",children:"Caching"}),"\n",(0,t.jsx)(n.p,{children:"Offset mapping can be cached for repeated use:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Generate and save mapping\nkafka-backup show-offset-mapping \\\n  --bootstrap-servers kafka:9092 \\\n  --all-topics \\\n  --source-cluster "prod" \\\n  --output mapping.json\n\n# Use cached mapping for multiple resets\nkafka-backup offset-reset execute \\\n  --strategy from-mapping \\\n  --mapping-file mapping.json \\\n  --groups group1,group2,group3\n'})}),"\n",(0,t.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,t.jsx)(n.h3,{id:"verify-offset-reset",children:"Verify Offset Reset"}),"\n",(0,t.jsx)(n.p,{children:"After resetting offsets:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Check consumer group positions\nkafka-consumer-groups \\\n  --bootstrap-server target-kafka:9092 \\\n  --group order-processor \\\n  --describe\n"})}),"\n",(0,t.jsx)(n.h3,{id:"verify-data-continuity",children:"Verify Data Continuity"}),"\n",(0,t.jsx)(n.p,{children:"Ensure consumers will process correct messages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Show what message consumer will receive next\nkafka-console-consumer \\\n  --bootstrap-server target-kafka:9092 \\\n  --topic orders \\\n  --partition 0 \\\n  --offset 100 \\\n  --max-messages 1 \\\n  --property print.headers=true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Check the ",(0,t.jsx)(n.code,{children:"x-kafka-backup-offset"})," header matches expected source offset."]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Always enable offset headers"})," during backup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use three-phase restore"})," for complete migrations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test offset reset"})," in non-production first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Take offset snapshots"})," before resetting (rollback capability)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verify consumer positions"})," after reset"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./pitr-implementation",children:"PITR Implementation"})," - How time filtering affects offsets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../guides/offset-management",children:"Offset Management Guide"})," - Practical offset operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../reference/cli-reference#three-phase-restore",children:"Three-Phase Restore"})," - CLI reference"]}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);