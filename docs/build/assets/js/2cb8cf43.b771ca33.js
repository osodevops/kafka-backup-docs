"use strict";(globalThis.webpackChunkkafka_backup_docs=globalThis.webpackChunkkafka_backup_docs||[]).push([[3376],{2035:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"architecture/pitr-implementation","title":"PITR Implementation","description":"How point-in-time recovery works in OSO Kafka Backup","source":"@site/docs/architecture/pitr-implementation.md","sourceDirName":"architecture","slug":"/architecture/pitr-implementation","permalink":"/architecture/pitr-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/osodevops/kafka-backup-docs/tree/main/docs/docs/architecture/pitr-implementation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"PITR Implementation","description":"How point-in-time recovery works in OSO Kafka Backup","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Offset Translation","permalink":"/architecture/offset-translation"},"next":{"title":"Compression","permalink":"/architecture/compression"}}');var r=i(4848),s=i(8453);const a={title:"PITR Implementation",description:"How point-in-time recovery works in OSO Kafka Backup",sidebar_position:3},o="Point-in-Time Recovery Implementation",c={},l=[{value:"How PITR Works",id:"how-pitr-works",level:2},{value:"Timestamp-Based Filtering",id:"timestamp-based-filtering",level:3},{value:"Timestamp Types",id:"timestamp-types",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Basic PITR Restore",id:"basic-pitr-restore",level:3},{value:"Using ISO 8601 Format",id:"using-iso-8601-format",level:3},{value:"Restore to Specific Point",id:"restore-to-specific-point",level:3},{value:"Restore from Specific Point",id:"restore-from-specific-point",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Segment-Level Filtering",id:"segment-level-filtering",level:3},{value:"Record-Level Filtering",id:"record-level-filtering",level:3},{value:"Manifest Time Ranges",id:"manifest-time-ranges",level:3},{value:"Per-Topic Time Windows",id:"per-topic-time-windows",level:2},{value:"PITR Use Cases",id:"pitr-use-cases",level:2},{value:"Scenario 1: Data Corruption Recovery",id:"scenario-1-data-corruption-recovery",level:3},{value:"Scenario 2: Incident Investigation",id:"scenario-2-incident-investigation",level:3},{value:"Scenario 3: Regulatory Audit",id:"scenario-3-regulatory-audit",level:3},{value:"Scenario 4: Rolling Back a Release",id:"scenario-4-rolling-back-a-release",level:3},{value:"Timestamp Considerations",id:"timestamp-considerations",level:2},{value:"Producer Timestamp Accuracy",id:"producer-timestamp-accuracy",level:3},{value:"Clock Skew",id:"clock-skew",level:3},{value:"LogAppendTime Configuration",id:"logappendtime-configuration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Time-Based Segment Selection",id:"time-based-segment-selection",level:3},{value:"Streaming Filter",id:"streaming-filter",level:3},{value:"Parallel Partition Processing",id:"parallel-partition-processing",level:3},{value:"Verification",id:"verification",level:2},{value:"Verify Time Range",id:"verify-time-range",level:3},{value:"Describe Backup Time Range",id:"describe-backup-time-range",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Timestamp Resolution",id:"timestamp-resolution",level:3},{value:"No Transaction Boundaries",id:"no-transaction-boundaries",level:3},{value:"Compacted Topics",id:"compacted-topics",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"point-in-time-recovery-implementation",children:"Point-in-Time Recovery Implementation"})}),"\n",(0,r.jsx)(n.p,{children:"OSO Kafka Backup provides millisecond-precision point-in-time recovery (PITR), allowing you to restore Kafka data to any specific moment."}),"\n",(0,r.jsx)(n.h2,{id:"how-pitr-works",children:"How PITR Works"}),"\n",(0,r.jsx)(n.h3,{id:"timestamp-based-filtering",children:"Timestamp-Based Filtering"}),"\n",(0,r.jsx)(n.p,{children:"Every Kafka record has a timestamp. PITR uses these timestamps to filter which records are restored:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Backup Contains Records:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 T=1000  T=1001  T=1002  T=1003  T=1004  T=1005  T=1006      \u2502\n\u2502   \u2502       \u2502       \u2502       \u2502       \u2502       \u2502       \u2502         \u2502\n\u2502   \u25bc       \u25bc       \u25bc       \u25bc       \u25bc       \u25bc       \u25bc         \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510      \u2502\n\u2502 \u2502 A \u2502   \u2502 B \u2502   \u2502 C \u2502   \u2502 D \u2502   \u2502 E \u2502   \u2502 F \u2502   \u2502 G \u2502      \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPITR Request: time_window_start=1002, time_window_end=1005\n\nRestored Records:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   T=1002  T=1003  T=1004  T=1005             \u2502\n\u2502                     \u2502       \u2502       \u2502       \u2502               \u2502\n\u2502                     \u25bc       \u25bc       \u25bc       \u25bc               \u2502\n\u2502                   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510             \u2502\n\u2502                   \u2502 C \u2502   \u2502 D \u2502   \u2502 E \u2502   \u2502 F \u2502             \u2502\n\u2502                   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"timestamp-types",children:"Timestamp Types"}),"\n",(0,r.jsx)(n.p,{children:"Kafka records have two timestamp types:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"When Set"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"CreateTime"})}),(0,r.jsx)(n.td,{children:"When producer created the record"}),(0,r.jsx)(n.td,{children:"Producer-side"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LogAppendTime"})}),(0,r.jsx)(n.td,{children:"When broker received the record"}),(0,r.jsx)(n.td,{children:"Broker-side"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"PITR filters based on the record's actual timestamp, regardless of type."}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"basic-pitr-restore",children:"Basic PITR Restore"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'mode: restore\nbackup_id: "production-backup-20241201"\n\nrestore:\n  # Unix timestamp in milliseconds\n  time_window_start: 1701388800000  # Dec 1, 2024 00:00:00 UTC\n  time_window_end: 1701475199000    # Dec 1, 2024 23:59:59 UTC\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-iso-8601-format",children:"Using ISO 8601 Format"}),"\n",(0,r.jsx)(n.p,{children:"The CLI accepts human-readable timestamps:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'kafka-backup restore \\\n  --config restore.yaml \\\n  --time-start "2024-12-01T00:00:00Z" \\\n  --time-end "2024-12-01T23:59:59Z"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"restore-to-specific-point",children:"Restore to Specific Point"}),"\n",(0,r.jsx)(n.p,{children:"Restore everything up to a specific moment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  time_window_end: 1701450000000  # Stop at this point\n  # Omit time_window_start to include all earlier records\n"})}),"\n",(0,r.jsx)(n.h3,{id:"restore-from-specific-point",children:"Restore from Specific Point"}),"\n",(0,r.jsx)(n.p,{children:"Restore everything after a specific moment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  time_window_start: 1701450000000  # Start from this point\n  # Omit time_window_end to include all later records\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.h3,{id:"segment-level-filtering",children:"Segment-Level Filtering"}),"\n",(0,r.jsx)(n.p,{children:"Backups are stored in segment files with time ranges:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"backup/\n\u251c\u2500\u2500 manifest.json\n\u2514\u2500\u2500 segments/\n    \u251c\u2500\u2500 segment-0000.dat   # T: 1000-2000\n    \u251c\u2500\u2500 segment-0001.dat   # T: 2001-3000\n    \u251c\u2500\u2500 segment-0002.dat   # T: 3001-4000\n    \u2514\u2500\u2500 segment-0003.dat   # T: 4001-5000\n\nPITR Request: T: 2500-3500\n\nSegments to read:\n  \u2717 segment-0000.dat  (T: 1000-2000) - Skip entirely\n  \u2713 segment-0001.dat  (T: 2001-3000) - Read, filter records\n  \u2713 segment-0002.dat  (T: 3001-4000) - Read, filter records\n  \u2717 segment-0003.dat  (T: 4001-5000) - Skip entirely\n"})}),"\n",(0,r.jsx)(n.p,{children:"This segment-level filtering significantly improves performance."}),"\n",(0,r.jsx)(n.h3,{id:"record-level-filtering",children:"Record-Level Filtering"}),"\n",(0,r.jsx)(n.p,{children:"Within each segment, individual records are filtered:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Pseudocode for record filtering\nfor record in segment.records() {\n    let timestamp = record.timestamp();\n\n    if let Some(start) = time_window_start {\n        if timestamp < start {\n            continue;  // Skip record before window\n        }\n    }\n\n    if let Some(end) = time_window_end {\n        if timestamp > end {\n            continue;  // Skip record after window\n        }\n    }\n\n    // Record is within window\n    output.write(record);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"manifest-time-ranges",children:"Manifest Time Ranges"}),"\n",(0,r.jsx)(n.p,{children:"The backup manifest tracks time ranges for efficient filtering:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "backup_id": "production-backup-20241201",\n  "topics": {\n    "orders": {\n      "partitions": {\n        "0": {\n          "segment_files": [\n            {\n              "file": "orders-0-0000.dat",\n              "start_offset": 0,\n              "end_offset": 9999,\n              "start_timestamp": 1701388800000,\n              "end_timestamp": 1701392400000,\n              "record_count": 10000\n            },\n            {\n              "file": "orders-0-0001.dat",\n              "start_offset": 10000,\n              "end_offset": 19999,\n              "start_timestamp": 1701392400001,\n              "end_timestamp": 1701396000000,\n              "record_count": 10000\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"per-topic-time-windows",children:"Per-Topic Time Windows"}),"\n",(0,r.jsx)(n.p,{children:"Different topics can have different recovery points:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  topics:\n    - name: orders\n      time_window_start: 1701388800000\n      time_window_end: 1701475199000\n\n    - name: payments\n      time_window_start: 1701400000000  # Different start\n      time_window_end: 1701475199000\n\n    - name: audit-log\n      # No time window - restore everything\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pitr-use-cases",children:"PITR Use Cases"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-1-data-corruption-recovery",children:"Scenario 1: Data Corruption Recovery"}),"\n",(0,r.jsx)(n.p,{children:"Bad data published at 14:30:00, restore to 14:29:59:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  # Restore everything before the corruption\n  time_window_end: 1701437399000  # 14:29:59\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-2-incident-investigation",children:"Scenario 2: Incident Investigation"}),"\n",(0,r.jsx)(n.p,{children:"Investigate data between 10:00 and 11:00:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  time_window_start: 1701421200000  # 10:00:00\n  time_window_end: 1701424800000    # 11:00:00\n\n  # Restore to investigation cluster\n  topic_mapping:\n    orders: investigation-orders\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-3-regulatory-audit",children:"Scenario 3: Regulatory Audit"}),"\n",(0,r.jsx)(n.p,{children:"Provide data as it existed on a specific date:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  # Full day - Dec 1, 2024\n  time_window_start: 1701388800000  # 00:00:00 UTC\n  time_window_end: 1701475199999    # 23:59:59.999 UTC\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-4-rolling-back-a-release",children:"Scenario 4: Rolling Back a Release"}),"\n",(0,r.jsx)(n.p,{children:"Restore data to state before deployment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"restore:\n  # Deployment started at 15:00\n  time_window_end: 1701442800000  # 14:59:59\n\n  # Only restore affected topics\n  topics:\n    - user-events\n    - notifications\n"})}),"\n",(0,r.jsx)(n.h2,{id:"timestamp-considerations",children:"Timestamp Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"producer-timestamp-accuracy",children:"Producer Timestamp Accuracy"}),"\n",(0,r.jsx)(n.p,{children:"For accurate PITR, ensure producers set correct timestamps:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Java producer example\nProducerRecord<String, String> record = new ProducerRecord<>(\n    "orders",\n    null,                           // partition\n    System.currentTimeMillis(),     // timestamp - set explicitly\n    key,\n    value\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"clock-skew",children:"Clock Skew"}),"\n",(0,r.jsx)(n.p,{children:"If producer clocks are skewed, PITR may not work as expected:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Producer A (clock +5 minutes): Record timestamp = 10:05\nProducer B (clock correct):    Record timestamp = 10:00\nActual time:                   10:00\n\nPITR restore to 10:02 would:\n  \u2713 Include record from Producer B (10:00)\n  \u2717 Exclude record from Producer A (10:05) - even though it was "really" at 10:00\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mitigation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use NTP synchronization on all producers"}),"\n",(0,r.jsxs)(n.li,{children:["Consider using ",(0,r.jsx)(n.code,{children:"LogAppendTime"})," for broker-controlled timestamps"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"logappendtime-configuration",children:"LogAppendTime Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Configure topics to use broker timestamp:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kafka-configs --bootstrap-server kafka:9092 \\\n  --entity-type topics --entity-name orders \\\n  --alter --add-config message.timestamp.type=LogAppendTime\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"time-based-segment-selection",children:"Time-Based Segment Selection"}),"\n",(0,r.jsx)(n.p,{children:"PITR avoids reading unnecessary segments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Backup: 100 segments (10 GB each = 1 TB total)\nPITR Window: 1 hour\n\nSegments in window: 4 segments (40 GB)\nSegments skipped: 96 segments (960 GB)\n\nI/O saved: 96%\n"})}),"\n",(0,r.jsx)(n.h3,{id:"streaming-filter",children:"Streaming Filter"}),"\n",(0,r.jsx)(n.p,{children:"Records are filtered during streaming, not post-processing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Storage \u2192 Read \u2192 Filter \u2192 Decompress \u2192 Write to Kafka\n                   \u2193\n            Skip early (no decompression overhead)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parallel-partition-processing",children:"Parallel Partition Processing"}),"\n",(0,r.jsx)(n.p,{children:"Each partition is processed in parallel with independent time filtering:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Partition 0: Filter T=1000-2000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nPartition 1: Filter T=1000-2000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25b6 Target Cluster\nPartition 2: Filter T=1000-2000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,r.jsx)(n.h3,{id:"verify-time-range",children:"Verify Time Range"}),"\n",(0,r.jsx)(n.p,{children:"After PITR restore, verify the time range:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check earliest message\nkafka-console-consumer \\\n  --bootstrap-server kafka:9092 \\\n  --topic orders \\\n  --from-beginning \\\n  --max-messages 1 \\\n  --property print.timestamp=true\n\n# Check latest message\nkafka-run-class kafka.tools.GetOffsetShell \\\n  --broker-list kafka:9092 \\\n  --topic orders \\\n  --time -1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"describe-backup-time-range",children:"Describe Backup Time Range"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kafka-backup describe \\\n  --path s3://bucket/backups \\\n  --backup-id production-20241201 \\\n  --format json | jq '.time_range'\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "earliest_timestamp": 1701388800000,\n  "latest_timestamp": 1701475199999,\n  "earliest_timestamp_iso": "2024-12-01T00:00:00Z",\n  "latest_timestamp_iso": "2024-12-01T23:59:59.999Z"\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsx)(n.h3,{id:"timestamp-resolution",children:"Timestamp Resolution"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka timestamps are millisecond precision"}),"\n",(0,r.jsx)(n.li,{children:"PITR is also millisecond precision"}),"\n",(0,r.jsx)(n.li,{children:"Sub-millisecond ordering is not guaranteed"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"no-transaction-boundaries",children:"No Transaction Boundaries"}),"\n",(0,r.jsx)(n.p,{children:"PITR filters by timestamp, not transaction boundaries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Transaction: Records A, B, C (all at T=1000)\nPITR end: T=999\n\nResult: Transaction partially restored (none of A, B, C)\n"})}),"\n",(0,r.jsx)(n.p,{children:"If transaction integrity is required, ensure time windows align with transaction boundaries."}),"\n",(0,r.jsx)(n.h3,{id:"compacted-topics",children:"Compacted Topics"}),"\n",(0,r.jsx)(n.p,{children:"For compacted topics, PITR works on the backup data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Backup contains: All records at backup time\nPITR restores: Subset by timestamp\n\nNote: Compaction state differs from source\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use consistent time sources"})," - NTP synchronization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document time zones"})," - Use UTC for clarity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test PITR regularly"})," - Verify recovery works"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include buffer time"})," - Add a few seconds margin"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify after restore"})," - Check time ranges match"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./offset-translation",children:"Offset Translation"})," - Consumer offset handling with PITR"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../guides/restore-pitr",children:"Restore PITR Guide"})," - Practical PITR operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../reference/cli-reference#restore",children:"CLI Reference"})," - Restore command options"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);